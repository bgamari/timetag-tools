#!/usr/bin/python
# vim: set fileencoding=utf-8 et :

# timetag-tools - Tools for UMass FPGA timetagger
# 
# Copyright Â© 2010 Ben Gamari
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
# 
# Author: Ben Gamari <bgamari@physics.umass.edu>
# 


import logging
from collections import defaultdict, namedtuple
import time
from datetime import datetime
import os, sys
import pkgutil

import gobject, gtk
import matplotlib
from matplotlib.figure import Figure
from matplotlib.backends.backend_gtk import FigureCanvasGTK
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg
from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo

from timetag.capture_pipeline import CapturePipeline, TestPipeline

StrobeConfig = namedtuple('StrobeConfig', 'enabled color label')
DeltaConfig = namedtuple('DeltaConfig', 'enabled label')
def_strobe_config = [
                StrobeConfig(True, '#A80505', 'Strobe 1'),
                StrobeConfig(True, '#006619', 'Strobe 2'),
                StrobeConfig(False, '#0142D5', 'Strobe 3'),
                StrobeConfig(False, '#922FFF', 'Strobe 4')
                ]
def_delta_config = [
                DeltaConfig(False, 'Delta 1'),
                DeltaConfig(False, 'Delta 2'),
                DeltaConfig(False, 'Delta 3'),
                DeltaConfig(False, 'Delta 4')
                ]

class NumericalIndicators(object):
        def __init__(self, main_win):
                self.main_win = main_win
                self.pipeline = main_win.pipeline
                self.rate_mode = True
                self.last_stats = defaultdict(lambda: (0, 0)) # counts, timestamp
                self.last_loss_count = 0
                self.last_timestamp = 0

                self.inputs = {}
                table = gtk.Table(len(main_win.strobe_config)+1, 3)

                label = gtk.Label()
                label.set_markup('<span foreground="darkred" size="large">Loss Events</span>')
                table.attach(label, 0,1, 0,1)
                self.lost = gtk.Label()
                table.attach(self.lost, 1,2, 0,1)

                for c,config in enumerate(main_win.strobe_config):
                        if not config.enabled: continue
                        label, photons = gtk.Label(), gtk.Label()
                        label.set_markup('<span foreground="%s" size="large">%s</span>' % (config.color, config.label))
                        table.attach(label, 0,1, c+1,c+2)
                        table.attach(photons, 1,2, c+1,c+2)
                        self.inputs[c] = photons

                self.widget = table

        def update(self):
                if self.rate_mode:
                        self._update_rate_indicators()
                else:
                        self._update_total_indicators()

        def _update_rate_indicators(self):
                for n, photon_count, timestamp in self.pipeline.stats():
                        if n not in self.inputs: continue
                        last_photon_count, last_timestamp = self.last_stats[n]
                        if last_timestamp != timestamp:
                                photon_rate = (photon_count - last_photon_count) / (timestamp - last_timestamp)

                                markup = "<span color='darkgreen' size='xx-large'>%d</span> <span size='large'>photons/s</span>" % photon_rate
                                self.inputs[n].set_markup(markup)
                        self.last_stats[n] = (photon_count, timestamp)

                if self.pipeline.latest_timestamp != self.last_timestamp:
                        loss_rate = (self.pipeline.loss_count - self.last_loss_count) / (self.pipeline.latest_timestamp - self.last_timestamp)
                        markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>losses/s</span>" % loss_rate
                        self.lost.set_markup(markup)
                self.last_timestamp = self.pipeline.latest_timestamp

        def _update_total_indicators(self):
                for n, photon_count, lost_count, timestamp in self.pipeline.stats():
                        if n not in self.inputs: continue
                        markup = "<span color='darkgreen' size='xx-large'>%1.3e</span> <span size='large'>photons</span>" % photon_count
                        self.inputs[n][0].set_markup(markup)
                        markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>loss events</span>" % lost_count
                        self.inputs[n][1].set_markup(markup)


class BinSeriesPlot(object):
        FigureCanvas = FigureCanvasGTK

        def __init__(self, main_win):
                def fix_color(c):
                        c = gtk.gdk.color_parse(c.color)
                        return (1./0xffff*c.red, 1./0xffff*c.green, 1./0xffff*c.red)
                self.colors = [ fix_color(c) for c in main_win.strobe_config ]

                self.plot_update_rate = 12 # in Hertz
                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'bin_series.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                self.win = self.builder.get_object('bin_series_window')
                def closed(unused):
                        main_win.bin_series_win_closed()
                self.win.connect('destroy', closed)

                self.scroll = False
                self.width = 10 # seconds
                self.y_bounds = None

                self.main_win = main_win
                self.sync_timestamp = 0
                self.sync_walltime = 0
                self.builder.get_object('x_width').props.value = 10 # HACK: set default
                self.figure = Figure()
                self.axes = self.figure.add_subplot(111)
                self.axes.get_xaxis().set_major_formatter(
                                matplotlib.ticker.ScalarFormatter(useOffset=False))
                self.axes.set_xlabel('Time (s)')
                self.axes.set_ylabel('Counts per bin')
                self.lines = {}
                canvas = self.__class__.FigureCanvas(self.figure)
                self.builder.get_object('plot_container').pack_start(canvas)
                self.win.show_all()

                self.fps_interval = 5 # seconds
                self.frame_cnt = 0
                def display_fps():
                        if not self.frame_cnt > 0: return True
                        fps = self.frame_cnt / self.fps_interval
                        self.frame_cnt = 0
                        logging.debug("Plot: %2.1f FPS" % fps)
                        return True
                gobject.timeout_add_seconds(self.fps_interval, display_fps)

                # Start update loop
                def update_plot():
                        if not self.pipeline or not self.running:
                                return False
                        try:
                                self.update()
                        except AttributeError as e:
                                # Ignore exceptions in case pipeline is shut down
                                raise e
                        return True

                self.running = True
                gobject.timeout_add(int(1000.0/self.plot_update_rate), update_plot)

        def close(self):
                self.running = False
                self.win.hide()

        @property
        def pipeline(self):
                return self.main_win.pipeline

        def update(self):
                if not self.pipeline:
                        return False

                max_counts = 0
                for n,times,counts in self.pipeline.bins():
                        max_counts = max(max_counts, max(counts))
                        if not self.main_win.strobe_config[n].enabled: continue
                        if not self.lines.has_key(n):
                                self.lines[n], = self.axes.plot(times, counts, color=self.colors[n])
                        else:
                                self.lines[n].set_data(times, counts)

                self.axes.relim()

                # Scale X axis:
                def calc_x_bounds():
                        xmax = self.sync_timestamp
                        if self.scroll:
                                xmax += time.time() - self.sync_walltime
                        xmin = xmax - self.width
                        return xmin, xmax

                xmin, xmax = calc_x_bounds()
                if not xmin < self.pipeline.latest_timestamp < xmax:
                        self.sync_walltime = time.time()
                        self.sync_timestamp = self.pipeline.latest_timestamp
                        xmin, xmax = calc_x_bounds()

                self.axes.set_xlim(xmin, xmax)

                # Scale Y axis:
                ymin,ymax = 0, 1.1*max_counts
                if self.y_bounds:
                        ymin, ymax = self.y_bounds
                self.axes.set_ylim(ymin, ymax)

                self.figure.canvas.draw()
                self.frame_cnt += 1

        @property
        def plot_width(self):
                return self.builder.get_object('x_width').props.value

        @property
        def n_points(self):
                """ The required number of points to fill the entire
                width of the plot at the given bin_time """
                return self.plot_width / self.main_win.bin_time

        def x_width_value_changed_cb(self, *args):
                if not self.pipeline: return
                self.pipeline.resize_buffer(self.n_points)
                self.width = self.plot_width

        def y_bounds_changed_cb(self, *args):
                get_object = self.builder.get_object

                auto = get_object('y_auto').props.active
                for o in [ 'y_upper_spin', 'y_lower_spin' ]:
                        get_object(o).props.sensitive = not auto

                if auto:
                        self.y_bounds = None
                else:
                        self.y_bounds = (get_object('y_lower').props.value,
                                         get_object('y_upper').props.value)

class HistPlot(object):
        FigureCanvas = FigureCanvasGTKCairo
        def __init__(self, main_win):
                def fix_color(c):
                        c = gtk.gdk.color_parse(c.color)
                        return (1./0xffff*c.red, 1./0xffff*c.green, 1./0xffff*c.red)
                self.colors = [ fix_color(c) for c in main_win.strobe_config ]

                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'hist.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                self.win = self.builder.get_object('hist_window')
                def closed(unused):
                        main_win.hist_win_closed()
                self.win.connect('destroy', closed)

                self.main_win = main_win
                self.pipeline = main_win.pipeline
                self.figure = Figure()
                self.axes = []
                for i in range(4):
                        axes = self.figure.add_subplot(140+i)
                        axes.get_xaxis().set_major_formatter(
                                        matplotlib.ticker.ScalarFormatter(useOffset=False))
                        axes.set_xlabel('Counts per bin')
                        self.axes.append(axes)

                canvas = self.__class__.FigureCanvas(self.figure)
                self.builder.get_object('plot_container').pack_start(canvas)
                self.builder.get_object('bin_width').value = 10 # HACK: set default
                self.win.show_all()

                def update_plot():
                        if not self.running:
                                return False
                        try:
                                self.update()
                        except AttributeError as e:
                                # Ignore exceptions in case pipeline is shut down
                                raise e
                        return True

                self.running = True
                gobject.timeout_add(int(1000.0/3), update_plot)

        def close(self):
                self.running = False
                self.win.hide()

        def update(self):
                hist_width = self.pipeline.hist_width
                for c,chan in self.pipeline.channels.items():
                        h = chan.hist
                        if len(h) == 0: continue
                        self.axes[c].cla()
                        self.axes[c].bar(h.keys(), h.values(), hist_width, alpha=0.5, color=self.colors[c])
                        self.axes[c].relim()

                self.figure.canvas.draw()

        def bin_width_value_changed_cb(self, adj):
                self.pipeline.hist_width = adj.get_value()

def run_channel_editor(parent, strobe_config, delta_config):
        win = gtk.Dialog('Channel Editor', parent,
                        gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                        (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                         gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
        vbox = gtk.VBox()
        win.get_content_area().pack_start(vbox)

        # Strobe channels
        strobes = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(strobe_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Strobe %d</i>' % i)
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                c = gtk.ColorButton(gtk.gdk.color_parse(config.color))
                table.attach(c, 2, 3, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                strobes.append((e,c,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)

        # Delta channels
        deltas = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(delta_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Delta %d</i>' % (i+1))
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                deltas.append((e,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)
        win.show_all()
        if win.run() == gtk.RESPONSE_REJECT:
                win.hide()
                return None

        win.hide()
        return ([ StrobeConfig(e.get_active(), c.get_color().to_string(), l.get_text()) for e,c,l in strobes ],
                [ DeltaConfig(e.get_active(), l.get_text()) for e,l in deltas ])
        
class MainWindow(object):
        def __init__(self, n_inputs=4):
                self.indicators_update_rate = 5 # in Hertz
                if use_test_pipeline:
                        self.pipeline = TestPipeline(100)
                else:
                        self.pipeline = CapturePipeline()
                self.readout_running = False

                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'main.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                get_obj = self.builder.get_object

                def quit(unused):
                        if self.pipeline:
                                self.stop_readout()
                                self.pipeline.stop()
                        gtk.main_quit()
                self.win = get_obj('main_window')
                self.win.connect('destroy', quit)

                self.set_default_output_file()
                self.bin_series_win = None
                self.hist_win = None
                self.indicators = None
                self.load_rc()

                # Start indicators update loop
                def update_indicators():
                        self.indicators.update()
                        return True
                gobject.timeout_add(int(1000.0/self.indicators_update_rate), update_indicators)

                self.win.show_all()

        def load_rc(self):
                import json
                get_obj = self.builder.get_object
                rc = {}
                f = os.path.expanduser('~/.timetagrc')
                if os.path.isfile(f):
                        try:
                                rc = json.load(open(f))
                        except Exception as e:
                                logging.warn('Warning: Failed to load RC: %s' % e)
                                pass

                get_obj('bin_time').value = rc.get('bin_time', 10)
                self.strobe_config = def_strobe_config
                if 'strobe_config' in rc:
                        self.strobe_config = [ StrobeConfig(*a) for a in rc['strobe_config'] ]
                self.delta_config = def_delta_config
                if 'delta_config' in rc:
                        self.delta_config = [ DeltaConfig(*a) for a in rc['delta_config'] ]

        def save_rc(self):
                import json
                get_obj = self.builder.get_object
                rc = {
                        'bin_time': get_obj('bin_time').value,
                        'strobe_config': self.strobe_config,
                        'delta_config': self.delta_config,
                }
                f = os.path.expanduser('~/.timetagrc')
                json.dump(rc, open(f, 'w'), indent=2)

        def edit_channels_activate_cb(self, action):
                res = run_channel_editor(self.win, self.strobe_config, self.delta_config)
                if not res: return
                self.strobe_config, self.delta_config = res
                self.save_rc()

        @property
        def strobe_config(self):
                return self._strobe_config

        @strobe_config.setter
        def strobe_config(self, config):
                self._strobe_config = config
                stats = self.builder.get_object('channel_stats')
                if self.indicators:
                        stats.remove(self.indicators.widget)
                self.indicators = NumericalIndicators(self)
                stats.pack_start(self.indicators.widget)
                self.indicators.widget.show_all()

        @property
        def bin_time(self):
                return self.builder.get_object('bin_time').props.value / 1000.0

        def usb_latency_changed_cb(self, combobox):
                iter = combobox.get_active_iter()
                latency = combobox.get_model().get_value(iter, 0)
                self.pipeline.set_send_window(latency)

        def set_default_output_file(self):
                file_n = 0
                def get_name(file_n):
                        now = datetime.today()
                        return "%04u-%02u-%02u-run_%03u.timetag" % \
                                (now.year, now.month, now.day, file_n)

                while os.path.exists(get_name(file_n)):
                        file_n += 1
                self.builder.get_object('output_file').props.text = get_name(file_n)

        def output_file_icon_press_cb(self, entry, icon_pos, event):
                self.select_output_file()

        def bin_time_value_changed_cb(self, adj):
                bin_time = adj.props.value
                self.pipeline.stop_binner()
                self.pipeline.start_binner(bin_time)

        def select_output_file(self):
                filter = gtk.FileFilter()
                filter.set_name('Timetag data file')
                filter.add_pattern('*.timetag')

                fc = gtk.FileChooserDialog('Select output file', self.win,
                                gtk.FILE_CHOOSER_ACTION_SAVE,
                                (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                 gtk.STOCK_OK, gtk.RESPONSE_OK))
                fc.add_filter(filter)
                fc.props.do_overwrite_confirmation = True
                res = fc.run()
                fc.hide()
                if res == gtk.RESPONSE_OK:
                        self.builder.get_object('output_file').props.text = fc.get_filename()

        def start_readout(self):
                get_obj = self.builder.get_object
                output_enabled = get_obj('file_output_enabled').props.active
                if output_enabled:
                        outfile = get_obj('output_file').props.text
                        self.pipeline.start_output_file(outfile)

                        import json
                        description = get_obj('description').get_buffer().props.text
                        channels = {}
                        for i in range(4):
                                if self.strobe_config[i].enabled:
                                        channels['strobe%d' % i] = self.strobe_config[i].label
                                if self.delta_config[i].enabled:
                                        channels['delta%d' % i] = self.delta_config[i].label

                        metadata = {
                                'start': datetime.now().isoformat(),
                                'clockrate': self.pipeline.clockrate,
                                'instrument': 'FPGA time tagger',
                                'hardware version': self.pipeline.hw_version,
                                'description': description,
                                'channels': channels,
                        }
                        meta_file = outfile + ".meta"
                        json.dump(metadata, open(meta_file, 'w'), indent=2)

                self.pipeline.start_binner(10e-3)
                self.pipeline.reset_counter()
                self.pipeline.start_capture()
                self.readout_running = True
                get_obj('file_output_enabled').props.sensitive = False
                get_obj('output_file').props.sensitive = False

                if self.bin_series_win:
                        self.bin_series_win.scroll = True

        def stop_readout(self):
                get_obj = self.builder.get_object
                self.pipeline.stop_binner()
                self.pipeline.stop_capture()
                if get_obj('file_output_enabled').props.active:
                        self.pipeline.stop_output_file()
                self.readout_running = False
                # So people don't overwrite the data they just took
                get_obj('file_output_enabled').props.active = False
                get_obj('file_output_enabled').props.sensitive = True
                get_obj('output_file').props.sensitive = True
                if self.bin_series_win:
                        self.bin_series_win.scroll = False

        def readout_running_toggled_cb(self, action):
                if action.props.active:
                        self.start_readout()
                        action.props.label = "Running"       
                else:
                        self.stop_readout()
                        action.props.label = "Stopped"

        def indicator_mode_changed_cb(self, widget):
                active = self.builder.get_object('show_rates').props.active
                self.indicators.rate_mode = bool(active)

        def show_hist_toggled_cb(self, action):
                if action.props.active:
                        self.hist_win = HistPlot(self)
                else:
                        self.hist_win.close()
                        self.hist_win = None

        def show_bin_series_toggled_cb(self, action):
                if action.props.active:
                        self.bin_series_win = BinSeriesPlot(self)
                        self.bin_series_win.scroll = self.readout_running
                else:
                        self.bin_series_win.close()
                        self.bin_series_win = None

        def bin_series_win_closed(self):
                self.builder.get_object('show_bin_series').props.active = False

        def hist_win_closed(self):
                self.builder.get_object('show_hist').props.active = False

if __name__ == '__main__':
        from optparse import OptionParser

        parser = OptionParser()
        parser.add_option('-d', '--debug', action='store_true',
                          help='Enable debugging output')
        parser.add_option('-t', '--test', action='store_true',
                          help="Use test input pipeline instead of actual hardware")
        opts, args = parser.parse_args()
        use_test_pipeline = opts.test
        if opts.debug:
                logging.basicConfig(level=logging.DEBUG)

        gtk.gdk.threads_init()
        win = MainWindow()
        gtk.main()

