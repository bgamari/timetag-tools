#!/usr/bin/python
# vim: set fileencoding=utf-8 et :

# timetag-tools - Tools for UMass FPGA timetagger
# 
# Copyright Â© 2010 Ben Gamari
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
# 
# Author: Ben Gamari <bgamari@physics.umass.edu>
# 


import os, sys
import logging
from collections import defaultdict, namedtuple
import time
from datetime import datetime
import pkgutil
import json

import gobject, gtk
import matplotlib
from matplotlib.figure import Figure
from matplotlib.backends.backend_gtk import FigureCanvasGTK
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg
from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo

from timetag.capture_pipeline import CapturePipeline, TestPipeline
from timetag.bin_series_plot import BinSeriesPlot
from timetag.hist_plot import HistPlot

StrobeConfig = namedtuple('StrobeConfig', 'enabled color label')
DeltaConfig = namedtuple('DeltaConfig', 'enabled label')
def_strobe_config = [
                StrobeConfig(True, '#A80505', 'Strobe 1'),
                StrobeConfig(True, '#006619', 'Strobe 2'),
                StrobeConfig(False, '#0142D5', 'Strobe 3'),
                StrobeConfig(False, '#922FFF', 'Strobe 4')
                ]
def_delta_config = [
                DeltaConfig(False, 'Delta 1'),
                DeltaConfig(False, 'Delta 2'),
                DeltaConfig(False, 'Delta 3'),
                DeltaConfig(False, 'Delta 4')
                ]

class NumericalIndicators(object):
        def __init__(self, main_win):
                self.main_win = main_win
                self.pipeline = main_win.pipeline
                self.rate_mode = True
                self.last_stats = defaultdict(lambda: (0, 0)) # counts, timestamp
                self.last_loss_count = 0
                self.last_timestamp = 0

                self.inputs = {}
                table = gtk.Table(len(main_win.strobe_config)+1, 3)

                label = gtk.Label()
                label.set_markup('<span foreground="darkred" size="large">Loss Events</span>')
                table.attach(label, 0,1, 0,1)
                self.lost = gtk.Label()
                table.attach(self.lost, 1,2, 0,1)

                for c,config in enumerate(main_win.strobe_config):
                        if not config.enabled: continue
                        label, photons = gtk.Label(), gtk.Label()
                        label.set_markup('<span foreground="%s" size="large">%s</span>' % (config.color, config.label))
                        table.attach(label, 0,1, c+1,c+2)
                        table.attach(photons, 1,2, c+1,c+2)
                        self.inputs[c] = photons

                self.widget = table

        def update(self):
                if self.rate_mode:
                        self._update_rate_indicators()
                else:
                        self._update_total_indicators()

        def _update_rate_indicators(self):
                for n, photon_count, timestamp in self.pipeline.stats():
                        if n not in self.inputs: continue
                        last_photon_count, last_timestamp = self.last_stats[n]
                        if last_timestamp != timestamp:
                                photon_rate = (photon_count - last_photon_count) / (timestamp - last_timestamp)

                                markup = "<span color='darkgreen' size='xx-large'>%d</span> <span size='large'>photons/s</span>" % photon_rate
                                self.inputs[n].set_markup(markup)
                        self.last_stats[n] = (photon_count, timestamp)

                if self.pipeline.latest_timestamp != self.last_timestamp:
                        loss_rate = (self.pipeline.loss_count - self.last_loss_count) / (self.pipeline.latest_timestamp - self.last_timestamp)
                        markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>losses/s</span>" % loss_rate
                        self.lost.set_markup(markup)

                self.last_timestamp = self.pipeline.latest_timestamp
                self.last_loss_count = self.pipeline.loss_count

        def _update_total_indicators(self):
                for n, photon_count, timestamp in self.pipeline.stats():
                        if n not in self.inputs: continue
                        markup = "<span color='darkgreen' size='xx-large'>%1.3e</span> <span size='large'>photons</span>" % photon_count
                        self.inputs[n].set_markup(markup)

                markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>losses</span>" % self.pipeline.loss_count
                self.lost.set_markup(markup)

def run_channel_editor(parent, strobe_config, delta_config):
        win = gtk.Dialog('Channel Editor', parent,
                        gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                        (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                         gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
        vbox = gtk.VBox()
        win.get_content_area().pack_start(vbox)

        # Strobe channels
        strobes = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(strobe_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Strobe %d</i>' % i)
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                c = gtk.ColorButton(gtk.gdk.color_parse(config.color))
                table.attach(c, 2, 3, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                strobes.append((e,c,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)

        # Delta channels
        deltas = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(delta_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Delta %d</i>' % (i+1))
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                deltas.append((e,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)
        win.show_all()
        if win.run() == gtk.RESPONSE_REJECT:
                win.hide()
                return None

        win.hide()
        return ([ StrobeConfig(e.get_active(), c.get_color().to_string(), l.get_text()) for e,c,l in strobes ],
                [ DeltaConfig(e.get_active(), l.get_text()) for e,l in deltas ])
        
class MainWindow(object):
        def __init__(self, n_inputs=4):
                self.indicators_update_rate = 5 # in Hertz
                if use_test_pipeline:
                        self.pipeline = TestPipeline(100)
                else:
                        self.pipeline = CapturePipeline()
                self.readout_running = False

                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'main.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                get_obj = self.builder.get_object

                def quit(unused):
                        if self.pipeline:
                                self.stop_readout()
                                self.pipeline.stop()
                        gtk.main_quit()
                self.win = get_obj('main_window')
                self.win.connect('destroy', quit)

                self.set_default_output_file()
                get_obj('bin_time_spin').props.value = 10
                get_obj('bin_time').props.value = 10
                self.bin_series_win = None
                self.hist_win = None
                self.indicators = None
                self.load_rc()

                # Start indicators update loop
                def update_indicators():
                        self.indicators.update()
                        return True
                gobject.timeout_add(int(1000.0/self.indicators_update_rate), update_indicators)

                self.win.show_all()

        def load_rc(self):
                import json
                get_obj = self.builder.get_object
                rc = {}
                f = os.path.expanduser('~/.timetagrc')
                if os.path.isfile(f):
                        try:
                                rc = json.load(open(f))
                        except Exception as e:
                                logging.warn('Warning: Failed to load RC: %s' % e)
                                pass

                get_obj('bin_time').value = rc.get('bin_time', 10)
                self.strobe_config = def_strobe_config
                if 'strobe_config' in rc:
                        self.strobe_config = [ StrobeConfig(*a) for a in rc['strobe_config'] ]
                self.delta_config = def_delta_config
                if 'delta_config' in rc:
                        self.delta_config = [ DeltaConfig(*a) for a in rc['delta_config'] ]

        def save_rc(self):
                import json
                get_obj = self.builder.get_object
                rc = {
                        'bin_time': get_obj('bin_time').value,
                        'strobe_config': self.strobe_config,
                        'delta_config': self.delta_config,
                }
                f = os.path.expanduser('~/.timetagrc')
                json.dump(rc, open(f, 'w'), indent=2)

        def edit_channels_activate_cb(self, action):
                res = run_channel_editor(self.win, self.strobe_config, self.delta_config)
                if not res: return
                self.strobe_config, self.delta_config = res
                self.save_rc()

        @property
        def strobe_config(self):
                return self._strobe_config

        @strobe_config.setter
        def strobe_config(self, config):
                self._strobe_config = config
                stats = self.builder.get_object('channel_stats')
                if self.indicators:
                        stats.remove(self.indicators.widget)
                self.indicators = NumericalIndicators(self)
                stats.pack_start(self.indicators.widget)
                self.indicators.widget.show_all()

        @property
        def bin_time(self):
                return self.builder.get_object('bin_time').props.value * 1e-3

        def usb_latency_changed_cb(self, combobox):
                iter = combobox.get_active_iter()
                latency = combobox.get_model().get_value(iter, 0)
                self.pipeline.set_send_window(latency)

        def set_default_output_file(self):
                file_n = 0
                def get_name(file_n):
                        now = datetime.today()
                        return "%04u-%02u-%02u-run_%03u.timetag" % \
                                (now.year, now.month, now.day, file_n)

                while os.path.exists(get_name(file_n)):
                        file_n += 1
                self.builder.get_object('output_file').props.text = get_name(file_n)

        def output_file_icon_press_cb(self, entry, icon_pos, event):
                self.select_output_file()

        def bin_time_value_changed_cb(self, adj):
                bin_time = adj.props.value
                self.pipeline.stop_binner()
                self.pipeline.start_binner(bin_time)

        def select_output_file(self):
                filter = gtk.FileFilter()
                filter.set_name('Timetag data file')
                filter.add_pattern('*.timetag')

                fc = gtk.FileChooserDialog('Select output file', self.win,
                                gtk.FILE_CHOOSER_ACTION_SAVE,
                                (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                                 gtk.STOCK_OK, gtk.RESPONSE_OK))
                fc.add_filter(filter)
                fc.props.do_overwrite_confirmation = True
                res = fc.run()
                fc.hide()
                if res == gtk.RESPONSE_OK:
                        self.builder.get_object('output_file').props.text = fc.get_filename()

        def start_readout(self):
                get_obj = self.builder.get_object
                output_enabled = get_obj('file_output_enabled').props.active
                if output_enabled:
                        outfile = get_obj('output_file').props.text
                        outfile = os.path.expanduser(outfile)
                        if os.path.exists(outfile):
                                dialog = gtk.MessageDialog(
                                                parent=self.win,
                                                flags=gtk.DIALOG_MODAL,
                                                type=gtk.MESSAGE_QUESTION,
                                                buttons=gtk.BUTTONS_YES_NO,
                                                message_format='The file "%s" already exists. Replace?' % outfile)
                                resp = dialog.run()
                                dialog.hide()
                                del dialog
                                if resp != gtk.RESPONSE_YES:
                                        get_obj('readout_running').props.active = False
                                        get_obj('readout_running').props.label = "Stopped"
                                        return

                        self.pipeline.start_output_file(outfile)
                        description = get_obj('description').get_buffer().props.text
                        channels = {}
                        for i in range(4):
                                if self.strobe_config[i].enabled:
                                        channels['strobe%d' % i] = self.strobe_config[i].label
                                if self.delta_config[i].enabled:
                                        channels['delta%d' % i] = self.delta_config[i].label

                        metadata = {
                                'start': datetime.now().isoformat(),
                                'clockrate': self.pipeline.clockrate,
                                'instrument': 'FPGA time tagger',
                                'hardware version': self.pipeline.hw_version,
                                'description': description,
                                'channels': channels,
                        }
                        meta_file = outfile + ".meta"
                        json.dump(metadata, open(meta_file, 'w'), indent=2)

                self.pipeline.reset_counter()
                self.pipeline.start_capture()
                self.pipeline.start_binner(self.bin_time)
                self.readout_running = True
                if self.bin_series_win:
                        self.bin_series_win.scroll = True

                get_obj('readout_running').props.active = True
                get_obj('readout_running').props.label = "Running"
                get_obj('file_output_enabled').props.sensitive = False
                get_obj('output_file').props.sensitive = False
                get_obj('acq_time_enabled').props.sensitive = False
                get_obj('acq_time_spin').props.sensitive = False

                progressbar = get_obj('progressbar')
                self.acq_time = 0
                acq_timer_enabled = get_obj('acq_time_enabled').props.active
                acq_stop_time = get_obj('acq_time').props.value
                def timer_cb():
                        if not self.readout_running:
                                return False
                        self.acq_time += 1
                        progressbar.props.text = 'Acquired %d:%02d' % \
                                        (self.acq_time/60, self.acq_time%60)
                        if acq_timer_enabled:
                                progressbar.set_fraction(self.acq_time / acq_stop_time)
                        else:
                                progressbar.pulse()
                        if acq_timer_enabled and self.acq_time >= acq_stop_time:
                                self.stop_readout()
                                return False
                        return True

                gobject.timeout_add_seconds(1, timer_cb)

        def stop_readout(self):
                get_obj = self.builder.get_object
                get_obj('readout_running').props.active = False
                get_obj('readout_running').props.label = "Stopped"
                self.pipeline.stop_binner()
                self.pipeline.stop_capture()
                if get_obj('file_output_enabled').props.active:
                        self.pipeline.stop_output_file()
                self.readout_running = False
                if self.bin_series_win:
                        self.bin_series_win.scroll = False

                # So people don't overwrite the data they just took
                get_obj('file_output_enabled').props.active = False
                get_obj('file_output_enabled').props.sensitive = True
                get_obj('output_file').props.sensitive = True
                get_obj('acq_time_enabled').props.sensitive = True
                get_obj('acq_time_spin').props.sensitive = True
                get_obj('progressbar').props.text = 'Not running'

        def readout_running_toggled_cb(self, action):
                if action.props.active:
                        self.start_readout()
                else:
                        self.stop_readout()

        def indicator_mode_changed_cb(self, widget):
                active = self.builder.get_object('show_rates').props.active
                self.indicators.rate_mode = bool(active)

        def show_hist_toggled_cb(self, action):
                if action.props.active:
                        self.hist_win = HistPlot(self)
                else:
                        self.hist_win.close()
                        self.hist_win = None

        def show_bin_series_toggled_cb(self, action):
                if action.props.active:
                        self.bin_series_win = BinSeriesPlot(self)
                        self.bin_series_win.scroll = self.readout_running
                else:
                        self.bin_series_win.close()
                        self.bin_series_win = None

        def bin_series_win_closed(self):
                self.builder.get_object('show_bin_series').props.active = False

        def hist_win_closed(self):
                self.builder.get_object('show_hist').props.active = False

if __name__ == '__main__':
        from optparse import OptionParser

        parser = OptionParser()
        parser.add_option('-d', '--debug', action='store_true',
                          help='Enable debugging output')
        parser.add_option('-t', '--test', action='store_true',
                          help="Use test input pipeline instead of actual hardware")
        opts, args = parser.parse_args()
        use_test_pipeline = opts.test
        if opts.debug:
                logging.basicConfig(level=logging.DEBUG)

        gtk.gdk.threads_init()
        win = MainWindow()
        gtk.main()

