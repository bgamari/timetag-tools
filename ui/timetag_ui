#!/usr/bin/python
# vim: set fileencoding=utf-8 et :

# timetag-tools - Tools for UMass FPGA timetagger
# 
# Copyright Â© 2010 Ben Gamari
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/ .
# 
# Author: Ben Gamari <bgamari@physics.umass.edu>
# 


import logging
from collections import defaultdict, namedtuple
import time
from datetime import datetime
import os, sys
import pkgutil

import gobject, gtk
import matplotlib
from matplotlib.figure import Figure
#from matplotlib.backends.backend_gtk import FigureCanvasGTK as FigureCanvas
#from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas

from timetag.capture_pipeline import CapturePipeline, TestPipeline

StrobeConfig = namedtuple('StrobeConfig', 'enabled color label')
DeltaConfig = namedtuple('DeltaConfig', 'enabled label')
class NumericalIndicators(object):
        def __init__(self, main_win):
                self.main_win = main_win
                self.rate_mode = True
                self.last_stats = defaultdict(lambda: (0, 0, 0))

                self.inputs = {}
                table = gtk.Table(len(main_win.strobe_config), 3)
                for c,config in enumerate(main_win.strobe_config):
                        if not config.enabled: continue
                        label, photons, lost = gtk.Label(), gtk.Label(), gtk.Label()
                        label.set_markup('<span foreground="%s" size="large">%s</span>' % (config.color.to_string(), config.label))
                        table.attach(label, 0,1, c,c+1)
                        table.attach(photons, 1,2, c,c+1)
                        table.attach(lost, 2,3, c,c+1)
                        self.inputs[c] = (photons, lost)

                self.widget = table

        def update(self):
                if self.rate_mode:
                        self._update_rate_indicators()
                else:
                        self._update_total_indicators()

        def _update_rate_indicators(self):
                for n, photon_count, lost_count, timestamp in self.main_win.pipeline.stats():
                        if n not in self.inputs: continue
                        last_photon_count, last_lost_count, last_timestamp = self.last_stats[n]
                        if last_timestamp != timestamp:
                                photon_rate = (photon_count - last_photon_count) / (timestamp - last_timestamp)
                                loss_rate = (lost_count - last_lost_count) / (timestamp - last_timestamp)

                                markup = "<span color='darkgreen' size='xx-large'>%d</span> <span size='large'>photons/s</span>" % photon_rate
                                self.inputs[n][0].set_markup(markup)
                                markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>losses/s</span>" % loss_rate
                                self.inputs[n][1].set_markup(markup)
                        self.last_stats[n] = (photon_count, lost_count, timestamp)


        def _update_total_indicators(self):
                for n, photon_count, lost_count, timestamp in self.main_win.pipeline.stats():
                        if n not in self.inputs: continue
                        markup = "<span color='darkgreen' size='xx-large'>%1.3e</span> <span size='large'>photons</span>" % photon_count
                        self.inputs[n][0].set_markup(markup)
                        markup = "<span color='darkred' size='xx-large'>%d</span> <span size='large'>loss events</span>" % lost_count
                        self.inputs[n][1].set_markup(markup)


class BinSeriesPlot(object):
        def __init__(self, main_win):
                self.colors = [ (1./0xffff*c.color.red, 1./0xffff*c.color.green, 1./0xffff*c.color.red)
                                for c in main_win.strobe_config ]
                self.plot_update_rate = 20 # in Hertz
                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'bin_series.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                self.win = self.builder.get_object('bin_series_window')
                def closed(unused):
                        main_win.bin_series_win_closed()
                self.win.connect('destroy', closed)

                self.scroll = False
                self.width = 1
                self.y_bounds = None

                self.main_win = main_win
                self.sync_timestamp = 0
                self.sync_walltime = 0
                self.builder.get_object('x_width').props.value = 1 # HACK: set default
                self.figure = Figure()
                self.axes = self.figure.add_subplot(111)
                self.axes.get_xaxis().set_major_formatter(
                                matplotlib.ticker.ScalarFormatter(useOffset=False))
                self.axes.set_xlabel('Time (s)')
                self.axes.set_ylabel('Counts per bin')
                self.lines = {}
                canvas = FigureCanvas(self.figure)
                self.builder.get_object('plot_container').pack_start(canvas)
                self.win.show_all()

                self.fps_interval = 5 # seconds
                self.frame_cnt = 0
                def display_fps():
                        if not self.frame_cnt > 0: return True
                        fps = self.frame_cnt / self.fps_interval
                        self.frame_cnt = 0
                        logging.debug("Plot: %2.1f FPS" % fps)
                        return True
                gobject.timeout_add_seconds(self.fps_interval, display_fps)

                # Start update loop
                def update_plot():
                        if not self.pipeline or not self.running:
                                return False
                        try:
                                self.update()
                        except AttributeError as e:
                                # Ignore exceptions in case pipeline is shut down
                                raise e
                        return True

                self.running = True
                gobject.timeout_add(int(1000.0/self.plot_update_rate), update_plot)

        def close(self):
                self.running = False
                self.win.hide()

        @property
        def pipeline(self):
                return self.main_win.pipeline

        def update(self):
                if not self.pipeline:
                        return False

                for n,times,counts in self.pipeline.bins():
                        if not self.main_win.strobe_config[n].enabled: continue
                        if not self.lines.has_key(n):
                                self.lines[n], = self.axes.plot(times, counts, color=self.colors[n])
                        else:
                                self.lines[n].set_data(times, counts)

                self.axes.relim()

                # Scale X axis:
                def calc_x_bounds():
                        xmax = self.sync_timestamp
                        if self.scroll:
                                xmax += time.time() - self.sync_walltime
                        xmin = xmax - self.width
                        return xmin, xmax

                xmin, xmax = calc_x_bounds()
                if not xmin < self.pipeline.latest_timestamp < xmax:
                        self.sync_walltime = time.time()
                        self.sync_timestamp = self.pipeline.latest_timestamp
                        xmin, xmax = calc_x_bounds()

                self.axes.set_xlim(xmin, xmax)

                # Scale Y axis:
                ymin,ymax = None,None
                if self.y_bounds:
                        ymin, ymax = self.y_bounds
                else:
                        self.axes.autoscale_view(scalex=False, scaley=True, tight=False)
                        _,ymax = self.axes.get_ylim()
                        ymax *= 1.1
                        ymin = 0
                self.axes.set_ylim(ymin, ymax)

                self.figure.canvas.draw()
                self.frame_cnt += 1

        @property
        def plot_width(self):
                return self.builder.get_object('x_width').props.value

        @property
        def n_points(self):
                """ The required number of points to fill the entire
                width of the plot at the given bin_time """
                return self.plot_width / self.main_win.bin_time

        def x_width_value_changed_cb(self, *args):
                if not self.pipeline: return
                self.pipeline.resize_buffer(self.n_points)
                self.width = self.plot_width

        def y_bounds_changed_cb(self, *args):
                get_object = self.builder.get_object

                auto = get_object('y_auto').props.active
                for o in [ 'y_upper_spin', 'y_lower_spin' ]:
                        get_object(o).props.sensitive = not auto

                if auto:
                        self.y_bounds = None
                else:
                        self.y_bounds = (get_object('y_lower').props.value,
                                         get_object('y_upper').props.value)

class HistPlot(object):
        def __init__(self, main_win):
                self.colors = [ (1./0xffff*c.color.red, 1./0xffff*c.color.green, 1./0xffff*c.color.red)
                                for c in main_win.strobe_config ]
                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'hist.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                self.win = self.builder.get_object('hist_window')
                def closed(unused):
                        main_win.hist_win_closed()
                self.win.connect('destroy', closed)

                self.main_win = main_win
                self.figure = Figure()
                self.axes = self.figure.add_subplot(111)
                self.axes.get_xaxis().set_major_formatter(
                                matplotlib.ticker.ScalarFormatter(useOffset=False))
                self.axes.set_xlabel('Counts per bin')
                canvas = FigureCanvas(self.figure)
                self.builder.get_object('plot_container').pack_start(canvas)
                self.builder.get_object('bin_width').value = 10 # HACK: set default
                self.win.show_all()

                def update_plot():
                        if not self.pipeline or not self.running:
                                return False
                        try:
                                self.update()
                        except AttributeError as e:
                                # Ignore exceptions in case pipeline is shut down
                                raise e
                        return True

                self.running = True
                gobject.timeout_add(int(1000.0/3), update_plot)

        def close(self):
                self.running = False
                self.win.hide()

        @property
        def pipeline(self):
                return self.main_win.pipeline

        def update(self):
                if not self.pipeline:
                        return False

                self.axes.cla()
                hist_width = self.pipeline.hist_width

                for c,chan in self.pipeline.channels.items():
                        h = chan.hist
                        if len(h) == 0: continue
                        self.axes.bar(h.keys(), h.values(), hist_width, alpha=0.5, color=self.colors[c])

                self.axes.relim()
                self.figure.canvas.draw()

        def bin_width_value_changed_cb(self, adj):
                self.pipeline.hist_width = adj.get_value()

def run_channel_editor(parent, strobe_config, delta_config):
        win = gtk.Dialog('Channel Editor', parent,
                        gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                        (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                         gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
        vbox = gtk.VBox()
        win.get_content_area().pack_start(vbox)

        # Strobe channels
        strobes = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(strobe_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Strobe %d</i>' % i)
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                c = gtk.ColorButton(config.color)
                table.attach(c, 2, 3, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                strobes.append((e,c,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)

        # Delta channels
        deltas = []
        table = gtk.Table(rows=4, columns=4)
        for config,i in zip(delta_config, range(4)):
                a = gtk.Label()
                a.set_markup('<i>Delta %d</i>' % (i+1))
                table.attach(a, 0, 1, i, i+1)

                e = gtk.CheckButton('Enabled')
                e.set_active(config.enabled)
                table.attach(e, 1, 2, i, i+1)

                l = gtk.Entry()
                l.set_text(config.label)
                table.attach(l, 3, 4, i, i+1)

                deltas.append((e,l))

        frame = gtk.Frame('Strobe')
        frame.add(table)
        vbox.pack_end(frame)
        win.show_all()
        if win.run() == gtk.RESPONSE_REJECT:
                win.hide()
                return None

        win.hide()
        return ([ StrobeConfig(e.get_active(), c.get_color(), l.get_text()) for e,c,l in strobes ],
                [ DeltaConfig(e.get_active(), l.get_text()) for e,l in deltas ])
        
class MainWindow(object):
        def __init__(self, n_inputs=4):
                self.indicators_update_rate = 5 # in Hertz
                self.pipeline = None
                color_parse = gtk.gdk.color_parse
                strobe_config = [
                                StrobeConfig(True, color_parse('#A80505'), 'Strobe 1'),
                                StrobeConfig(True, color_parse('#006619'), 'Strobe 2'),
                                StrobeConfig(False, color_parse('#0142D5'), 'Strobe 3'),
                                StrobeConfig(False, color_parse('#922FFF'), 'Strobe 4')
                                ]
                delta_config = [
                                DeltaConfig(False, 'Delta 1'),
                                DeltaConfig(False, 'Delta 2'),
                                DeltaConfig(False, 'Delta 3'),
                                DeltaConfig(False, 'Delta 4')
                                ]

                self.builder = gtk.Builder()
                src = pkgutil.get_data('timetag', 'main.glade')
                self.builder.add_from_string(src)
                self.builder.connect_signals(self)
                get_obj = self.builder.get_object

                def quit(unused):
                        if self.pipeline:
                                self.pipeline.stop()
                        gtk.main_quit()
                self.win = get_obj('main_window')
                self.win.connect('destroy', quit)

                self.set_default_output_file()
                self.bin_series_win = None
                self.hist_win = None
                self.indicators = None
                self.strobe_config = strobe_config # NumericalIndicators created here
                self.delta_config = delta_config
                get_obj('bin_time').value = 10 # HACK: set default

                self.win.show_all()

        def edit_channels_activate_cb(self, action):
                res = run_channel_editor(self.win, self.strobe_config, self.delta_config)
                if not res: return
                self.strobe_config, self.delta_config = res

        @property
        def strobe_config(self):
                return self._strobe_config

        @strobe_config.setter
        def strobe_config(self, config):
                self._strobe_config = config
                stats = self.builder.get_object('channel_stats')
                if self.indicators:
                        stats.remove(self.indicators.widget)
                self.indicators = NumericalIndicators(self)
                stats.pack_start(self.indicators.widget)
                self.indicators.widget.show_all()

        @property
        def bin_time(self):
                return self.builder.get_object('bin_time').props.value / 1000.0

        def usb_latency_changed_cb(self, combobox):
                iter = combobox.get_active_iter()
                latency = combobox.get_model().get_value(iter, 0)
                self.pipeline.set_send_window(latency)

        def set_default_output_file(self):
                file_n = 0
                def get_name(file_n):
                        now = datetime.today()
                        return "%04u-%02u-%02u-run_%03u.timetag" % \
                                (now.year, now.month, now.day, file_n)

                while os.path.exists(get_name(file_n)):
                        file_n += 1
                self.builder.get_object('output_file').props.text = get_name(file_n)

        def output_file_icon_press_cb(self, entry, icon_pos, event):
                self.select_output_file()

        def select_output_file(self):
                filter = gtk.FileFilter()
                filter.set_name('Timetag data file')
                filter.add_pattern('*.timetag')

                fc = gtk.FileChooserDialog('Select output file', self.win, gtk.FILE_CHOOSER_ACTION_SAVE,
                        (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,  gtk.STOCK_OK, gtk.RESPONSE_OK))
                fc.add_filter(filter)
                fc.props.do_overwrite_confirmation = True
                res = fc.run()
                fc.hide()
                if res == gtk.RESPONSE_OK:
                        self.builder.get_object('output_file').props.text = fc.get_filename()

        def start_pipeline(self):
                get_obj = self.builder.get_object
                output_enabled = get_obj('file_output_enabled').props.active
                if self.pipeline:
                        raise "Tried to start a capture pipeline while one is already running"

                outfile = None
                if output_enabled:
                        outfile = get_obj('output_file').props.text

                if use_test_pipeline:
                        self.pipeline = TestPipeline(100)
                else:
                        self.pipeline = CapturePipeline(output_file=outfile,
                                                        bin_time=self.bin_time,
                                                        npts=10)

                self.pipeline.start()
                self.pipeline.reset_counter()

                if output_enabled:
                        import json
                        description = get_obj('description').get_buffer().props.text
                        channels = {}
                        for i in range(4):
                                if self.strobe_config[i].enabled:
                                        channels['strobe%d' % i] = self.strobe_config[i].label
                                if self.delta_config[i].enabled:
                                        channels['delta%d' % i] = self.delta_config[i].label

                        metadata = {
                                'start': datetime.now().isoformat(),
                                'clockrate': self.pipeline.clockrate,
                                'instrument': 'FPGA time tagger',
                                'hardware version': self.pipeline.hw_version,
                                'description': description,
                                'channels': channels,
                        }
                        meta_file = outfile + ".meta"
                        json.dump(metadata, open(meta_file, 'w'), indent=2)


                # Start indicators update loop
                def update_indicators():
                        if not self.pipeline: return False
                        try:
                                self.indicators.update()
                        except AttributeError as e:
                                # Ignore exceptions if pipeline is shut down
                                raise e
                        return True

                gobject.timeout_add(int(1000.0/self.indicators_update_rate), update_indicators)

                if self.builder.get_object('show_hist').props.active:
                        self.hist_win = HistPlot(self)
                if self.builder.get_object('show_bin_series').props.active:
                        self.bin_series_win = BinSeriesPlot(self)

        def stop_pipeline(self):
                self.stop_readout()
                self.pipeline.stop()
                self.pipeline = None
                # As a precaution to prevent accidental overwriting of acquired data
                self.builder.get_object('file_output_enabled').props.active = False
                if self.bin_series_win:
                        self.bin_series_win.close()
                if self.hist_win:
                        self.hist_win.close()

        def pipeline_running_toggled_cb(self, action):
                get_object = self.builder.get_object
                state = action.props.active
                for o in [ 'file_output_enabled', 'output_file', 'bin_time_spin', 
                                'description', 'edit_channels' ]:
                        get_object(o).props.sensitive = not state
                for o in [ 'readout_running', 'usb_latency', 'show_hist', 'show_bin_series' ]:
                        get_object(o).props.sensitive = state

                if state:
                        self.start_pipeline()
                else:
                        get_object('readout_running').set_active(False)
                        self.stop_pipeline()

        def start_readout(self):
                self.pipeline.reset_counter()
                self.pipeline.start_capture()
                if self.bin_series_win:
                        self.bin_series_win.scroll = True

        def stop_readout(self):
                self.pipeline.stop_capture()
                if self.bin_series_win:
                        self.bin_series_win.scroll = False

        def readout_running_toggled_cb(self, action):
                if action.props.active:
                        self.start_readout()
                        action.props.label = "Running"       
                else:
                        self.stop_readout()
                        action.props.label = "Stopped"

        def indicator_mode_changed_cb(self, widget):
                active = self.builder.get_object('show_rates').props.active
                self.indicators.rate_mode = bool(active)

        def show_hist_toggled_cb(self, action):
                if action.props.active:
                        self.hist_win = HistPlot(self)
                else:
                        self.hist_win.close()
                        self.hist_win = None

        def show_bin_series_toggled_cb(self, action):
                if action.props.active:
                        self.bin_series_win = BinSeriesPlot(self)
                else:
                        self.bin_series_win.close()
                        self.bin_series_win = None

        def bin_series_win_closed(self):
                self.builder.get_object('show_bin_series').props.active = False

        def hist_win_closed(self):
                self.builder.get_object('show_hist').props.active = False

if __name__ == '__main__':
        from optparse import OptionParser

        parser = OptionParser()
        parser.add_option('-d', '--debug', action='store_true',
                          help='Enable debugging output')
        parser.add_option('-t', '--test', action='store_true',
                          help="Use test input pipeline instead of actual hardware")
        opts, args = parser.parse_args()
        use_test_pipeline = opts.test
        if opts.debug:
                logging.basicConfig(level=logging.DEBUG)

        gtk.gdk.threads_init()
        win = MainWindow()
        gtk.main()

